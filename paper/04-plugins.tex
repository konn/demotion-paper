% !TeX root = demotion-paper.tex
\documentclass[demotion-paper.tex]{subfiles}
\begin{document}
\section{Case Study: Dependently-typed Plugin System Parsed Dynamically}
\label{sec:plugins}

As an application of the methods developed in \Cref{sec:gcd,sec:disj}, now we look into more involved and practical example: demoting existing type-level constraints and resolve it dynamically with systematic change using witness pattern.

Suppose we have a program that reads a given input store and returns some outputs generated by prespecified plugins.
An input store is represented as a kind of extensible record indexed with a type-level list of fields, and plugins are also specified in type-level.
The following signature for the main logic illustrates the idea:
\begin{code}
type SPlugins ps = SList (ps :: [Plugin])
processStore :: All (RunsWith keys) ps
             => Store keys -> SPlugins ps -> Outputs ps

class IsPlugin (p :: Plugin) where
  data PluginStoreType p
  data PluginOutput p
  type Runnable p (keys :: [StoreKey]) :: Constraint
  process :: Runnable p keys => proxy p -> Store keys -> PluginOutput p

class Runnable p keys => RunsWith keys p
instance Runnable p keys => RunsWith keys p
\end{code}
Thus, each plugin \hask{p} has a type-level constraint \hask{Runnable p keys} (and its flipped version \hask{RunsWith keys p}) to determine if it is runnable with input stores with the given keys.
A function \hask{processStore} takes an input store and (a singleton of) a list of plugin runnable on the given store, and then returns the final outputs.
This works well if one explicitly specifies type variables \hask{keys} and \hask{ps} \emph{statically}.
Suppose that, however, now the situation is changed and we want to determine \hask{keys} and \hask{ps} \emph{dynamically}, depending on external configurations.
This poses two challenges:
\begin{enumerate}
  \item We have to resolve constraint \hask{All (RunsWith keys) p} at runtime, and
  \item We have to demote type-level operators as singletonised functions.
\end{enumerate}
In this section, we will see how we can apply witness pattern to achieve these goals safely.

\subsection{Overview of the Architecture of the Static API}\label{sec:static-api}
Before we get into implement claimed dynamic constraint resolution with witnesses, we first skim thorugh the original static API we consider.

Our example system is designed using so-called extensible records with the API presented in \Cref{lst:ext-rec-api}.
\begin{listing}[htbp]
\begin{code}
data Record (f :: k -> Type) (keys :: [k])
pattern EmptyRecord :: Record f '[]
pattern (:<) :: f k -> Record f keys -> Record f (k ': keys)

data Index k ks
type family LookupIndex k ks :: Maybe (Index k ks) where ...
type family LookupIndex' k ks = 
  FromJust ('Text "Key not found") (LookupIndex k ks)
type Member k ks = Known (LookupIndex' k ks)

getRecField :: Member k ks => Record f ks -> f k

type family All c keys :: Constraint where
  All c '[] = ()
  All c (k ': ks) = (c k, All c ks)
\end{code}
\caption{An abstract API of Extensible Records}
\label{lst:ext-rec-api}
\end{listing}
Here, \hask{Record f keys} is isomorphic to the record type with field labels in \hask{keys}, where each label \hask{k} is associated to the value of type \hask{f k}.
A type \hask{Index k ks} witnesses the membership of label \hask{k} in a type-level list \hask{ks}, and \hask{LookupIndex} type family computes such membership if it present.
\hask{LookupIndex'} is a variant of \hask{LookupIndex}, which returns raw membership at type-level if it is found, and throwing a type-error otherwise.
A function \hask{getRecField} traverses a given record along with a membership \hask{Index k ks} given by type-level constraint \hask{Member}, and returns corresponding field.

In practice, it is much more convenient to allow specify labels and corresponding field type independently, making \hask{f :: key -> val -> Type}.
Several efficient implementations can be found on Hackage~\cite{Kinoshita:2020aa,Sterling:2020aa,Thiemann:2020aa}.
Furthermore, it is desirable to use type-level ordered maps instead of lists to tune-up type-cheking speed.
Here, we adopt the above simple API for exposition.

Built on top of this API, we can now present the entire program architecture is listed in \Cref{lst:plugin-arch}.
\begin{listing}[hptb]
\begin{code}
data Plugin = Doubler | Greeter deriving (Eq, Show)
data StoreKey = IntStore | NameStore | PluginStore Plugin deriving (Eq, Show)

class IsPlugin (p :: Plugin) where
  data PluginStoreType p
  data PluginOutput p
  type Runnable p (keys :: [StoreKey]) :: Constraint
  process :: Runnable p keys => proxy p -> Store keys -> PluginOutput p

newtype StoreEntry k = MkStoreEntry {storeEntry :: StoreVal k}
type Store = Record StoreEntry
type Outputs = Record PluginOutput

type family StoreVal (key :: StoreKey) :: Type where
  StoreVal 'IntStore = Int
  StoreVal 'NameStore = String
  StoreVal ('PluginStore p) = PluginStoreType p

type SPlugins ps = SList (ps :: [Plugin])
processStore :: All (RunsWith ks) ps => Store ks -> SPlugins ps -> Outputs ps
processStore _ SNil = EmptyStore
processStore store (SCons p ps) = process p store :< processStore store ps
\end{code}
\caption{Static API of a (Dependently-Typed) Plugin System}
\label{lst:plugin-arch}
\end{listing}
As described before, \hask{processStore} is our main routine.
It processes \hask{Store} represented as an extensible record with label type \hask{StoreKey}, calculates \hask{PluginOutput} for each plugin specified in a type-level list \hask{ps}, and bundles them into a single extensible record \hask{Outputs ps}.
\hask{StoreKey} can be either \hask{IntStore}, \hask{NameStore} or \hask{PluginStore p} for some plugin \hask{p}, allowing storing plugin specific configuration in the store.

Let's see an actual implementations for plugins \hask{Doubler} and \hask{Greeter}.
\hask{Doubler} (\Cref{lst:plugin-double}) is simple: it reas the value of \hask{IntStore}, returns the value multiplied by $2$.
\begin{listing}[htbp]
\begin{code}
instance IsPlugin 'Doubler where
  data PluginStoreType 'Doubler = DoubleStore deriving (Show, Eq, Ord)
  newtype PluginOutput 'Doubler = OutputA Int deriving (Show, Eq, Ord)
  type Runnable 'Doubler keys = Member 'IntStore keys
  process _ store = OutputA $ 2 * getRecField @'IntStore store
\end{code}
\caption{An implementation of \textt{Doubler}.}
\label{lst:plugin-double}
\end{listing}
Hence it requires the value associated with \hask{IntStore}, \hask{Runnable 'Doubler} demands \hask{Member 'IntStore keys}; if there is no field with label \hask{IntStore}, it fails to type-check.

Another example, \hask{Greeter} (\Cref{lst:plugin-greet}) is much more complicated.
\begin{listing}
\begin{code}
type Greetable keys =
  ( Known (LookupIndex ( 'PluginStore 'Greeter) keys)
  , Greetable_ (LookupIndex ( 'PluginStore 'Greeter) keys) keys
  )

type family Greetable_ m keys :: Constraint where
  Greetable_ ( 'Just path) _ = ()
  Greetable_ 'Nothing keys = Known (LookupIndex 'NameStore keys)

makeGreet :: PluginStoreType 'Greeter -> String
instance IsPlugin 'Greeter where
  type Runnable 'Greeter keys = Greetable keys
  data PluginStoreType 'Greeter = GreetEnv
    { greetTarget :: String, greetTimes :: Int, greetOwner :: String }
  newtype PluginOutput 'Greeter = GreetOutput String deriving (Show)
  process _ (store :: Store keys) =
    case sing @(LookupIndex ('PluginStore 'Greeter) keys) of
      SJust idx -> withKnown idx $ GreetOutput $
        makeGreet $ getRecField @('PluginStore 'Greeter) store
      SNothing -> case sing @(LookupIndex 'NameStore keys) of
        SJust idx -> withKnown idx $ GreetOutput $ makeGreet $
          GreetEnv (getRecField @'IntStore store) 1 "Greeter"
        SNothing -> GreetOutput "I don't know who you are, anyway, Hi!"
\end{code}
\caption{An implementation of \texttt{Greeter}.}
\label{lst:plugin-greet}
\end{listing}
Its logic is as follows:
\begin{enumerate}
  \item If there is a field with label \hask{PluginStore Greeter}, generate greeting message based on it;
  \item if \hask{NameStore} is given, greet once to that name;
  \item otherwise, return the default greeting message.
\end{enumerate}
In short, \hask{Greeter} involves fallback strategy on fields in the input store.
This strategy is formulated as a \hask{Greetable} constraint; first try to inspect the exsitence of the label \hask{PluginStore Greeter}, and then fallback to the condition on the existence of \hask{PluginStore}.
This fallback strategy can be seeen as an application of the methods of emulating disjunction of type constraints\footnote{%
In this case, however, it woud suffice to require both \hask{Known (LookupIndex (PluginStore Greeter) keys)} and \hask{Known (LookupIndex NameStore keys)} would suffice. However, in more practical and perforfmance-critical applications, precise handling of disjunctive constraints is crucial.},
presented in \Cref{sec:disj}.

\subsection{Notes on Equality}
At this point, we have three type-level (homogeneous) equalities:
\begin{enumerate}
\item Built-in equality constraint \hask{a ~ b},
\item Boolean equality \hask{a == b}, which plays well with compound types, and
\item Boolean equality \hask{a === b}, which takes only the reflexivity into account.
\end{enumerate}
These three equalities can play their roles case-by-case, although their extension must coincide.
Hence, it is convenient to pack all these (non-)equalities into a single witness:

\begin{code}
data Equality a b where
  Equal :: ((a == b) ~ 'True, a ~ b, (a === b) ~ 'True) => Equality a b
  NonEqual
    :: ((a === b) ~ 'False, (a == b) ~ 'False) => Equality a b
\end{code}

As expressed by the constructor names, here \hask{Equal} witnesses the equality of given two types, and \hask{NonEqual} witnesses \emph{non}-equality.
In this way, \hask{Equality} packages both \emph{positive} (equal) and \emph{negative} (non-equal) witnesses.

One might wonder why we didn't mention equality \emph{constraint} \hask{a ~ b} in \hask{NonEqual}-case.
This is because GHC can infer that \hask{a :~: b} is not inhabited from the fact that \hask{(a === b) ~ 'False}:

\begin{code}
{-# LANGUAGE EmptyCase, LambdaCase #-}
import Data.Void
fromFalseEq :: (a === b) ~ 'False => a :~: b -> Void
fromFalseEq = \case {}
\end{code}

FIXME: coercion arguments has no runtime representation and {\hask{NonEqual}} and {\hask{Equal}} can be treated just as nullary constructors and hence we can treat type parameters {\hask{a}} and {\hask{b}} in {\hask{Equality a b}} as if they are phantom.


\end{document}
