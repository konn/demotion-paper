%!TeX root = demotion-paper.tex
\documentclass[demotion-paper.tex]{subfiles}
\begin{document}
\section{Case Study: Dependently-typed Plugin System Type-Checked Dynamically}
\label{sec:plugins}

As an application of the methods developed in \Cref{sec:gcd,sec:disj}, now we look into more involved and practical example: demoting existing type-level constraints and resolve it dynamically.

Suppose we have a program that reads a given input store and returns some outputs generated by prespecified plugins.
An input store is represented as an extensible record, and plugins are also specified in type-level.
The following signature for the main logic illustrates the idea:
\begin{code}
type SPlugins ps = SList (ps :: [Plugin])
processStore :: All (RunsOn keys) ps
  => Store keys -> SPlugins ps -> Outputs ps

class IsPlugin (p :: Plugin) where
  data PStoreType p
  data POutput p
  type Runnable p (ks :: [StoreKey]) :: Constraint
  process :: Runnable p keys
    => proxy p -> Store keys -> POutput p

class Runnable p keys => RunsOn keys p
instance Runnable p keys => RunsOn keys p
\end{code}
Thus, each plugin \hask{p} is given with a type-level constraint \hask{Runnable p keys} (and its flipped version \hask{RunsOn keys p}) to determine if it is runnable with input stores with the given keys.
A function \hask{processStore} takes an input store and (a singleton of) a list of plugin runnable on the given store, and then returns the final outputs.
This works well if one specifies type variables \hask{keys} and \hask{ps} \emph{statically}.
Suppose that, however, now the situation is changed and we want to determine \hask{ps} \emph{dynamically}, depending on external configurations.
This poses two challenges:
\begin{enumerate}
  \item We have to resolve constraint \hask{All (RunsOn keys) p} at runtime, and
  \item We have to demote type-level operators as singletonised functions.
\end{enumerate}
In this section, we will see how we can apply the witness-pattern to achieve these goals safely.

\subsection{Overview of the Architecture of the Static API}\label{sec:static-api}
Before we get into the dynamic constraint resolution with witnesses, we first skim through the original static API we consider.

Our example system is designed using extensible records, which we developed in \Cref{sec:disj}.
We present the entire program architecture in \Cref{lst:plugin-arch}.
\begin{listing}[tbp]
\begin{code}
data Plugin = Doubler | Greeter
data StoreKey = IntStore | NameStore
              | PStore Plugin

class IsPlugin (p :: Plugin) where
  data PStoreType p
  data POutput p
  type Runnable p (ks :: [StoreKey]) :: Constraint
  process :: Runnable p keys
    => proxy p -> Store keys -> POutput p

newtype StoreEntry k =
  MkStoreEntry {storeEntry :: StoreVal k}
type Store = Record StoreEntry
type Outputs = Record POutput

type family StoreVal key where
  StoreVal 'IntStore = Int
  StoreVal 'NameStore = String
  StoreVal ('PStore p) = PStoreType p

type SPlugins ps = SList (ps :: [Plugin])
processStore :: All (RunsOn ks) ps
  => Store ks -> SPlugins ps -> Outputs ps
processStore _ SNil = EmptyRecord
processStore store (SCons p ps) = 
  process p store :< processStore store ps
\end{code}
\caption{Static API of a Plugin System}
\label{lst:plugin-arch}
\end{listing}
As described before, \hask{processStore} is our main routine.
It processes \hask{Store} represented as an extensible record with labels of kind \hask{StoreKey}, calculates \hask{POutput} for each plugin specified by a type-level list \hask{ps}, and bundles them into a single extensible record \hask{Outputs ps}.
\hask{StoreKey} can be either \hask{IntStore}, \hask{NameStore}, or \hask{PStore p} for some plugin \hask{p}.

Let's see an actual implementations for plugins \hask{Doubler} and \hask{Greeter}.
\hask{Doubler} (\Cref{lst:plugin-double}) is simple: it reas the value of \hask{IntStore}, returns the value multiplied by $2$.
\begin{listing}[tbp]
\begin{code}
instance IsPlugin 'Doubler where
  data PStoreType 'Doubler = DoubleStore
  newtype POutput 'Doubler = OutputA Int
  type Runnable 'Doubler keys = 
    Member 'IntStore keys
  process _ store = OutputA $
    2 * getRecField @'IntStore store
\end{code}
\caption{An implementation of \textt{Doubler}.}
\label{lst:plugin-double}
\end{listing}
As it requires the value associated with \hask{IntStore}, \hask{Runnable 'Doubler} demands \hask{Member 'IntStore keys}.
Hence, if there is no field with label \hask{IntStore}, it fails to type-check.

Another example, \hask{Greeter}, in \Cref{lst:plugin-greet}, is much more complicated.
\begin{listing}[tbp]
\begin{code}
type Greetable keys =
  ( Known (FindIndex ( 'PStore 'Greeter) keys)
  , Greetable_ 
    (FindIndex ( 'PStore 'Greeter) keys) keys
  )

type family Greetable_ m keys :: Constraint where
  Greetable_ ( 'Just path) _ = ()
  Greetable_ 'Nothing keys = 
    Known (FindIndex 'NameStore keys)

makeGreet :: PStoreType 'Greeter -> String
instance IsPlugin 'Greeter where
  type Runnable 'Greeter keys = Greetable keys
  data PStoreType 'Greeter = GreetEnv
    { greetTarget :: String
    , greetTimes :: Int, greetOwner :: String }
  newtype POutput 'Greeter = 
    GreetOutput String deriving (Show)
  process _ (store :: Store keys) =
    case sing
        @(FindIndex ('PStore 'Greeter) keys) of
     SJust idx -> withKnown idx $ GreetOutput $
       makeGreet $ getRecField 
         @('PStore 'Greeter) store
     SNothing ->
      case sing @(FindIndex 'NameStore keys) of
       SJust idx -> withKnown idx $ GreetOutput $
         makeGreet $ GreetEnv
          (getRecField @'IntStore store)
          1 "Greeter"
       SNothing -> GreetOutput "Hi, someone!"
\end{code}
\caption{An implementation of \texttt{Greeter}.}
\label{lst:plugin-greet}
\end{listing}
Its logic is as follows:
\begin{enumerate}
  \item If there is a field with label \hask{PStore Greeter}, generate greeting message based on it;
  \item if \hask{NameStore} is given, greet once to that name;
  \item otherwise, return the default greeting message.
\end{enumerate}
In short, \hask{Greeter} involves fallback strategy on fields in the input store.
This strategy is formulated as a \hask{Greetable} constraint; first try to inspect the exsitence of the label \hask{PStore Greeter}, and then fallback to the condition on the existence of \hask{PStore}.
This fallback strategy can be seeen as an amalgamation of methods presented in \Cref{sec:gcd,sec:disj}, giving another way to emulate disjunction of constraints\footnote{%
In this case, however, it woud suffice to require both \hask{Known (FindIndex (PStore Greeter) keys)} and \hask{Known (FindIndex NameStore keys)}. However, in more complex case, it saves compilation time to use such fallback strategies.}.

Let's see some examples:
\begin{repl}
>>> processStore 
      (MkStoreEntry @NameStore "Superman"
        :< MkStoreEntry @IntStore 42
        :< EmptyRecord)
      (sing @'[Doubler, Greeter])
OutputA 84
  :< GreetOutput "Hi, Superman, from Greeter!"
  :< EmptyRecord

>>> processStore 
      (MkStoreEntry @NameStore "anonymous"
        :< EmptyRecord) 
      (sing @'[ Doubler])
Key `'IntStore' is absent in: '[ 'NameStore]

>>> processStore 
      (MkStoreEntry @NameStore "Ignored"
        :< MkStoreEntry @(PStore Greeter) 
            (GreetEnv "You" 2 "me")
        :< EmptyRecord) (sing @'[ 'Greeter])
GreetOutput "Hi, Hi, You, from me!" :< EmptyRecord
\end{repl}

\subsection{Make it dynamic}
OK, let's implement a dynamic variant of \hask{processStore}.
In particular, we will make the resolution of \hask{Runnable} constraints dynamic, implementing the following function:

\begin{code}
processStoreDynamic :: Known keys
  => Store keys -> [Plugin]
  -> Either String 
    (SomeRec (RunsOn keys) POutput)

data SomeRec c f where
  MkSomeRec :: All c keys => Sing keys
    -> Record f keys -> SomeRec c f
\end{code}

One nontrivial challenge here is to resolve constraints of form \hask{Runnable} at \emph{runtime}, not \emph{compile-time}.
First, there is a well-known design pattern to allow such instance resolutions at runtime: the \emph{deferrable constraint} pattern:
\begin{code}
class Deferrable p where
  deferEither :: proxy p -> (p => r) 
              -> Either String r
\end{code}
This is provided in the module \hask{Data.Constraint.Deferrable} in \texttt{constraints} package~\cite{Kmett:2020ab}, and it was first proposed by Dimitrios Vytiniotis\footnote{The author couldn't find the original reference proposing this pattern; pointers welcome!}.
Unfortunately, we cannot write instances of \hask{Deferrable (Runnable p keys)} in general, as \hask{Runnable} is a \emph{type family} and not a \emph{class constructor}.
Instead, we provide the dedicated class \hask{DynamicPlugin} of plugins which allow the deferral of corresponding \hask{Runnable}s:
\begin{code}
class IsPlugin p => DynamicPlugin p where
  deferDynamicPlugin
    :: Known keys
    => pxy p -> Proxy keys
    -> (Runnable p keys => r) -> Either String r
\end{code}

So it remains to implement \hask{IsPlugin} instances for each plugins.
Fortunately, all the \hask{Runnable} definitions defined so far can be resolved with singleton manipulation.

Let's see how to resolve \hask{Runnable 'Doubler keys} dynamically.
Recall its definition:
\begin{code}
type Runnable 'Doubler ks = Member 'IntStore ks
\end{code}
By definition, \hask{Member 'IntStore keys ~ Given (Index 'IntStore keys)} and the default implementation is resolved with the superclass constraint \hask{Known (FindIndex'  'IntStore keys)}.
Hence, assuming:
\begin{code}
sFindIndex :: Sing key -> SList keys
      -> SMaybe (FindIndex key keys)
\end{code}
we can implement \hask{DynamicPlugin 'Doubler} as follows:
\begin{code}
instance DynamicPlugin 'Doubler where
  deferDynamicPlugin _ (_ :: Proxy keys) act =
    case sFindIndex SIntStore $ sing @keys of
      SNothing -> Left "IntStore not found"
      SJust v -> withKnown v $ Right act
\end{code}
We can likewise implement the instance for \hask{Greeter}:
\begin{code}
instance DynamicPlugin 'Greeter where
  deferDynamicPlugin _ (_ :: Proxy keys) act =
    case sFindIndex (SPStore SGreeter) keys of
      SJust pth -> withKnown pth $ Right act
      SNothing ->
        withKnown (sFindIndex SNameStore keys) $
          Right act
    where keys = sing @keys
\end{code}

\subsubsection{The type-level equality strikes back!}
Hence, it remains to implement \hask{sFindIndex}.
Recall our current implementation of \hask{FindIndex}:
\begin{code}
type family FindIndex k ks where
  FindIndex _ '[] = 'Nothing
  FindIndex k (k ': ks) = 'Just 'Here
  FindIndex k (_ ': ks) =
    'There <$> FindIndex k ks  
\end{code}
A clever reader can notice that, as we did in \Cref{sec:gcd}, we have to modify this definition to recoginise \emph{witnesses} to distinguish evaluation paths.
This is exactly the case, and we make the following tweak:
\begin{code}
type FindIndex :: forall k ks -> Maybe (Index k ks)
type family FindIndex k ks where
  FindIndex _ '[] = 'Nothing
  FindIndex k (k' ': ks) = 
    FindIndexAux (k === k') k ks

type FindIndexAux
  :: forall k'. Bool -> forall k ks
  -> Maybe (Index k (k' ': ks))
type family FindIndexAux eql k rest where
  FindIndexAux 'True _ _ = 'Just 'Here
  FindIndexAux 'False k ks = 
    'There <$> FindIndex k ks
\end{code}
OK, now we can implement \hask{sFindIndex}:
\begin{code}
sFindIndex :: TestEquality (Sing @a)
  => Sing (k :: a) -> SList keys
  -> SMaybe (FindIndex k keys)
sFindIndex _ SNil = SNothing
sFindIndex k (SCons k ks') = case k %=== k' of
  STrue -> SJust SHere
  SFalse -> SThere %<$> sFindIndex k ks
\end{code}
...Well, not quite:
\begin{repl}
• Could not deduce: 
    FindIndexAux k x xs 'True ~ 'Just a0
  Expected type: SMaybe (FindIndex k keys1)
    Actual type: SMaybe ('Just a0)
  The type variable ‘a0’ is ambiguous
• In the expression: SJust SHere
  In a case alternative: STrue -> SJust SHere
\end{repl}
We expected \hask{a} to be \hask{Here :: Index k (k ': ks)}, but here it becomes ambiguous type variable. Why?
In the \hask{'True}-branch of \hask{FindIndexAux}, it returns \hask{Here}.
Recall that \hask{Here} has the following type:
\begin{code}
  Here :: Index k (k ': ks)
\end{code}
Or, equivalently,
\begin{code}
  Here :: k ~ k' => Index k (k' ': ks)
\end{code}
This tells us the reason why we got stuck: in \hask{STrue}-branch, GHC knows that \hask{(k === x) ~ 'True}, but GHC cannot infer \hask{k ~ x} from it!

To avoid such loss of equality information, it is convenient to pack all extensionally, but not definitionally, equivalent constraints.
Recall we have three type-level (homogeneous) equalities:
\begin{enumerate}
\item \hask{a ~ b}, the built-in equality constraint,
\item \hask{a == b}, a type-level boolean predicate that plays well with compound types but lacks automatic reflexivity, and
\item \hask{a === b}, a type-level boolean predicate which takes only the reflexivity into account.
\end{enumerate}
These three equalities can play their roles case-by-case, although their extensions must coincide.
So, it is useful to pack all these (non-)equalities into a single witness, as follows:
\begin{code}
data Equality a b where
  Equal :: ((a == b) ~ 'True, (a === b) ~ 'True,
            a ~ b) => Equality a b
  NonEqual :: ((a === b) ~ 'False, 
              (a == b) ~ 'False) => Equality a b
\end{code}
As expressed by the constructor names, here \hask{Equal} witnesses the equality of given two types, and \hask{NonEqual} witnesses \emph{non}-equality.
In this way, \hask{Equality} packages both \emph{positive} (equal) and \emph{negative} (non-equal) witnesses.

One might wonder why we didn't mention equality \emph{constraint} \hask{a ~ b} in \hask{NonEqual}-case.
This is because GHC can infer that \hask{a :~: b} is not inhabited from \hask{(a === b) ~ 'False}:

\begin{code}
{-# LANGUAGE EmptyCase, LambdaCase #-}
import Data.Void
fromFalseEq
  :: (a === b) ~ 'False => a :~: b -> Void
fromFalseEq = \case {}
\end{code}
To allow equality test with \hask{Equality} witnesses, we use the following class:
\begin{code}
class SEqual k where
  (%~) :: Sing (a :: k) -> Sing b -> Equality a b
\end{code}
Some reader might realise that this looks similar to \hask{SDecide} class in \texttt{singletons} package~\cite{singletons}.
The difference is non-equal cases: \haskinline{(%~)}
in \hask{SDecide} returns \hask{a :~: b -> Void} in the non-equal case.
This design decision works well if one only do with \hask{(~)}; however, we cannot derive \hask{(a == b) ~ 'False} or \hask{(a === b) ~ 'False} by the very same reason why we cannot use \haskinline{(%===)}
in the definition of \hask{sFindIndex}.

Anyway, since those three equalities coincides extensionally, we can derive instance definitions of \hask{SEqual} from either \hask{TestEquality} (from \texttt{base}) or \hask{SDecide}.
One can of course directly implement \hask{SEqual} by pattern matching.
For example:
\begin{code}
instance SEqual Plugin where
  SDoubler %~ SDoubler = Equal
  SDoubler %~ SGreeter = NonEqual
  SGreeter %~ SGreeter = Equal
  SGreeter %~ SDoubler = NonEqual
\end{code}
For \hask{StoreKey}, however, we need some hacks as it involves compound constructors:
\begin{code}
instance SEqual StoreKey where
  SIntStore %~ SIntStore = Equal
  SIntStore %~ SNameStore = NonEqual
  SIntStore %~ SPStore {} = NonEqual
  -- ... Similar for SNameStore %~ x ...
  SPStore p %~ SPStore q = case p %~ q of
      Equal -> Equal
      NonEqual -> nestNonEqual
  SPStore {} %~ SIntStore = NonEqual
  SPStore {} %~ SNameStore = NonEqual

nestNonEqual :: (a == b) ~ 'False => Equality a b
nestNonEqual = unsafeCoerce $ NonEqual @0 @1
\end{code}
The reason we cannot use \hask{NonEqual} in the \hask{SPStore}-case is that, as state before, \hask{(===)} won't inspect inside compound types.
On the other hand, since \hask{(==)} from \texttt{base} can correctly handle compound types, we can call combinator \hask{nestNonEqual} here.
By constraining with \hask{(a == b) ~ 'False}, \hask{nestNonEqual} tries to reject illegal usages as much as possible\footnote{Aside semantics, the use of \hask{unsafeCoerce} here is memory-safe, even without any constraints. This is because coercion arguments has no runtime representation. Therefore, constructors can be treated just as if they are nullary and hence we can treat type parameters as if they are phantom.}.

With \hask{SEqual} above, we can now implement \hask{sFindIndex}:
\begin{code}
sFindIndex :: SEqual a => Sing (k :: a)
  -> SList keys -> SMaybe (FindIndex k keys)
sFindIndex _ SNil = SNothing
sFindIndex k (SCons k' ks) =
  case k %~ k' of
    Equal -> SJust SHere
    NonEqual -> SThere %<$> sFindIndex k ks
\end{code}

As this filled the last gap, we can now implement our last goal \hask{processStoreDynamic} as listed in \Cref{lst:proc-dyn}.
\begin{listing}[tbhp]
\begin{code}
data PluginsOn keys where
  MkSomePlugins :: All (RunsOn keys) ps
    => SPlugins ps -> PluginsOn keys

toSomeDyns :: forall keys. Known keys
  => [Plugin] -> Either String (PluginsOn keys)
toSomeDyns [] = pure $ MkSomePlugins SNil
toSomeDyns (p : rest) = do
  MkSomePlugins ps <- toSomeDyns @keys rest
  withPromoted p $ \case
    SDoubler ->
      deferDynamicPlugin
        (Proxy @ 'Doubler) (Proxy @keys)
        (MkSomePlugins $ SCons SDoubler ps)
    SGreeter ->
      deferDynamicPlugin
        (Proxy @ 'Greeter) (Proxy @keys)
        (MkSomePlugins $ SCons SGreeter ps)

processStoreDynamic :: forall keys. Known keys
  => Store keys -> [Plugin]
  -> Either String (SomeRec (RunsOn keys) POutput)
processStoreDynamic store ps = do
  MkSomePlugins (sps :: SPlugins ps) 
    <- toSomeDyns @keys ps
  pure $ MkSomeRec sps $ processStore store sps
\end{code}
\caption{The implementation of \texttt{processStoreDynamic}}
\label{lst:proc-dyn}
\end{listing}

Now, we can test \hask{processStoreDynamic}:
\begin{repl}
>>> processStoreDynamic
      (MkStoreEntry @NameStore "Superman"
        :< MkStoreEntry @IntStore 42
        :< EmptyRecord)
      [Doubler, Greeter] -- it is a value!
Right (OutputA 84
  :< GreetOutput "Hi, Superman, from Greeter!"
  :< EmptyRecord)

>>> processStoreDynamic
      (MkStoreEntry @NameStore "anonymous"
        :< EmptyRecord) 
      [Doubler]
Left "Doubler requries IntStore key"
\end{repl}
\subsection{Summary}
We discussed the design of a statically-typed plugin system with dynamic instance resolution at runtime.
This was achieved by combining witness-aware constraint handling and Deferrable class.
We also discuss the design of the equality witness that can treat three distinct type-level equalities.
\end{document}
