%!TeX root = demotion-paper.tex
\documentclass[demotion-paper.tex]{subfiles}
\begin{document}
\section{Case Study: Dependently-typed Plugin System Parsed Dynamically}
\label{sec:plugins}
% TODO: Remove duplicated reference of extensible records and make in line with sec 3

As an application of the methods developed in \Cref{sec:gcd,sec:disj}, now we look into more involved and practical example: demoting existing type-level constraints and resolve it dynamically with systematic change using witness pattern.

Suppose we have a program that reads a given input store and returns some outputs generated by prespecified plugins.
An input store is represented as a kind of extensible record indexed with a type-level list of fields, and plugins are also specified in type-level.
The following signature for the main logic illustrates the idea:
\begin{code}
type SPlugins ps = SList (ps :: [Plugin])
processStore :: All (RunsWith keys) ps
             => Store keys -> SPlugins ps -> Outputs ps

class IsPlugin (p :: Plugin) where
  data PluginStoreType p
  data PluginOutput p
  type Runnable p (keys :: [StoreKey]) :: Constraint
  process :: Runnable p keys => proxy p -> Store keys -> PluginOutput p

class Runnable p keys => RunsWith keys p
instance Runnable p keys => RunsWith keys p
\end{code}
Thus, each plugin \hask{p} has a type-level constraint \hask{Runnable p keys} (and its flipped version \hask{RunsWith keys p}) to determine if it is runnable with input stores with the given keys.
A function \hask{processStore} takes an input store and (a singleton of) a list of plugin runnable on the given store, and then returns the final outputs.
This works well if one explicitly specifies type variables \hask{keys} and \hask{ps} \emph{statically}.
Suppose that, however, now the situation is changed and we want to determine \hask{keys} and \hask{ps} \emph{dynamically}, depending on external configurations.
This poses two challenges:
\begin{enumerate}
  \item We have to resolve constraint \hask{All (RunsWith keys) p} at runtime, and
  \item We have to demote type-level operators as singletonised functions.
\end{enumerate}
In this section, we will see how we can apply witness pattern to achieve these goals safely.

\subsection{Overview of the Architecture of the Static API}\label{sec:static-api}
Before we get into implement claimed dynamic constraint resolution with witnesses, we first skim thorugh the original static API we consider.

Our example system is designed using extensible records, which we developed in \Cref{sec:disj}.
Built on top of it, we can now present the entire program architecture in \Cref{lst:plugin-arch}.
\begin{listing}[hptb]
\begin{code}
data Plugin = Doubler | Greeter deriving (Eq, Show)
data StoreKey = IntStore | NameStore | PluginStore Plugin deriving (Eq, Show)

class IsPlugin (p :: Plugin) where
  data PluginStoreType p
  data PluginOutput p
  type Runnable p (keys :: [StoreKey]) :: Constraint
  process :: Runnable p keys => proxy p -> Store keys -> PluginOutput p

newtype StoreEntry k = MkStoreEntry {storeEntry :: StoreVal k}
type Store = Record StoreEntry
type Outputs = Record PluginOutput

type family StoreVal (key :: StoreKey) :: Type where
  StoreVal 'IntStore = Int
  StoreVal 'NameStore = String
  StoreVal ('PluginStore p) = PluginStoreType p

type SPlugins ps = SList (ps :: [Plugin])
processStore :: All (RunsWith ks) ps => Store ks -> SPlugins ps -> Outputs ps
processStore _ SNil = EmptyRecord
processStore store (SCons p ps) = process p store :< processStore store ps
\end{code}
\caption{Static API of a (Dependently-Typed) Plugin System}
\label{lst:plugin-arch}
\end{listing}
As described before, \hask{processStore} is our main routine.
It processes \hask{Store} represented as an extensible record with label type \hask{StoreKey}, calculates \hask{PluginOutput} for each plugin specified in a type-level list \hask{ps}, and bundles them into a single extensible record \hask{Outputs ps}.
\hask{StoreKey} can be either \hask{IntStore}, \hask{NameStore} or \hask{PluginStore p} for some plugin \hask{p}, allowing storing plugin specific configuration in the store.

Let's see an actual implementations for plugins \hask{Doubler} and \hask{Greeter}.
\hask{Doubler} (\Cref{lst:plugin-double}) is simple: it reas the value of \hask{IntStore}, returns the value multiplied by $2$.
\begin{listing}[htbp]
\begin{code}
instance IsPlugin 'Doubler where
  data PluginStoreType 'Doubler = DoubleStore deriving (Show, Eq, Ord)
  newtype PluginOutput 'Doubler = OutputA Int deriving (Show, Eq, Ord)
  type Runnable 'Doubler keys = Member 'IntStore keys
  process _ store = OutputA $ 2 * getRecField @'IntStore store
\end{code}
\caption{An implementation of \textt{Doubler}.}
\label{lst:plugin-double}
\end{listing}
Hence it requires the value associated with \hask{IntStore}, \hask{Runnable 'Doubler} demands \hask{Member 'IntStore keys}; if there is no field with label \hask{IntStore}, it fails to type-check.

Another example, \hask{Greeter} (\Cref{lst:plugin-greet}) is much more complicated.
\begin{listing}
\begin{code}
type Greetable keys =
  ( Known (FindIndex ( 'PluginStore 'Greeter) keys)
  , Greetable_ (FindIndex ( 'PluginStore 'Greeter) keys) keys
  )

type family Greetable_ m keys :: Constraint where
  Greetable_ ( 'Just path) _ = ()
  Greetable_ 'Nothing keys = Known (FindIndex 'NameStore keys)

makeGreet :: PluginStoreType 'Greeter -> String
instance IsPlugin 'Greeter where
  type Runnable 'Greeter keys = Greetable keys
  data PluginStoreType 'Greeter = GreetEnv
    { greetTarget :: String, greetTimes :: Int, greetOwner :: String }
  newtype PluginOutput 'Greeter = GreetOutput String deriving (Show)
  process _ (store :: Store keys) =
    case sing @(FindIndex ('PluginStore 'Greeter) keys) of
      SJust idx -> withKnown idx $ GreetOutput $
        makeGreet $ getRecField @('PluginStore 'Greeter) store
      SNothing -> case sing @(FindIndex 'NameStore keys) of
        SJust idx -> withKnown idx $ GreetOutput $ makeGreet $
          GreetEnv (getRecField @'IntStore store) 1 "Greeter"
        SNothing -> GreetOutput "I don't know who you are, anyway, Hi!"
\end{code}
\caption{An implementation of \texttt{Greeter}.}
\label{lst:plugin-greet}
\end{listing}
Its logic is as follows:
\begin{enumerate}
  \item If there is a field with label \hask{PluginStore Greeter}, generate greeting message based on it;
  \item if \hask{NameStore} is given, greet once to that name;
  \item otherwise, return the default greeting message.
\end{enumerate}
In short, \hask{Greeter} involves fallback strategy on fields in the input store.
This strategy is formulated as a \hask{Greetable} constraint; first try to inspect the exsitence of the label \hask{PluginStore Greeter}, and then fallback to the condition on the existence of \hask{PluginStore}.
This fallback strategy can be seeen as an amalgamation of methods presented in \Cref{sec:gcd,sec:disj}, giving another way to emulate disjunction of constraints\footnote{%
In this case, however, it woud suffice to require both \hask{Known (FindIndex (PluginStore Greeter) keys)} and \hask{Known (FindIndex NameStore keys)} would suffice. However, in more practical and perforfmance-critical applications, precise handling of disjunctive constraints is crucial.}.

Let's see some examples:
\begin{repl}
>>> processStore 
      (MkStoreEntry @NameStore "Superman" :< MkStoreEntry @IntStore 42
        :< EmptyRecord)
      (sing @'[Doubler, Greeter])
OutputA 84 :< (GreetOutput "Hi, Superman, from Greeter!" :< EmptyRecord)

>>> processStore (MkStoreEntry @NameStore "anonymous" :< EmptyRecord) 
      (sing @'[ Doubler])
Key `'IntStore' is absent in the list: '[ 'NameStore]

>>> processStore 
      (MkStoreEntry @NameStore "Ignored"
        :< MkStoreEntry @(PluginStore Greeter) (GreetEnv "You" 3 "me")
        :< EmptyRecord) (sing @'[ 'Greeter])
GreetOutput "Hi, Hi, Hi, You, from me!" :< EmptyRecord
\end{repl}

% FIXME: Words on sFindIndex
% Well, not quite.
% If one wants to implement singletonised version \hask{sFindIndex} of \hask{FindIndex}, we must apply the methods described in \Cref{sec:gcd} to make clear which branch is taken:
% \begin{code}
% type family FindIndex k ks where
%   FindIndex _ '[] = 'Nothing
%   FindIndex k (k' ': ks) = FindIndexAux (k === k') k ks

% type FindIndexAux :: forall k'. Bool -> forall k ks -> Maybe (Index k (k' ': ks))
% type family FindIndexAux eql k rest where
%   FindIndexAux 'True _ _ = 'Just 'Here
%   FindIndexAux 'False k ks = 'There `FMap` FindIndex k ks
% \end{code}


\subsection{Notes on Equality}
At this point, we have three type-level (homogeneous) equalities:
\begin{enumerate}
\item Built-in equality constraint \hask{a ~ b},
\item Boolean equality \hask{a == b}, which plays well with compound types, and
\item Boolean equality \hask{a === b}, which takes only the reflexivity into account.
\end{enumerate}
These three equalities can play their roles case-by-case, although their extension must coincide.
Hence, it is convenient to pack all these (non-)equalities into a single witness:

\begin{code}
data Equality a b where
  Equal :: ((a == b) ~ 'True, a ~ b, (a === b) ~ 'True) => Equality a b
  NonEqual
    :: ((a === b) ~ 'False, (a == b) ~ 'False) => Equality a b
\end{code}

As expressed by the constructor names, here \hask{Equal} witnesses the equality of given two types, and \hask{NonEqual} witnesses \emph{non}-equality.
In this way, \hask{Equality} packages both \emph{positive} (equal) and \emph{negative} (non-equal) witnesses.

One might wonder why we didn't mention equality \emph{constraint} \hask{a ~ b} in \hask{NonEqual}-case.
This is because GHC can infer that \hask{a :~: b} is not inhabited from the fact that \hask{(a === b) ~ 'False}:

\begin{code}
{-# LANGUAGE EmptyCase, LambdaCase #-}
import Data.Void
fromFalseEq :: (a === b) ~ 'False => a :~: b -> Void
fromFalseEq = \case {}
\end{code}

FIXME: coercion arguments has no runtime representation and {\hask{NonEqual}} and {\hask{Equal}} can be treated just as nullary constructors and hence we can treat type parameters {\hask{a}} and {\hask{b}} in {\hask{Equality a b}} as if they are phantom.


\end{document}
