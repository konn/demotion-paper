% !TeX root = demotion-paper.tex
\documentclass[demotion-paper.tex]{subfiles}
\begin{document}
\section{Case Study: Dependently-typed Plugin System Parsed Dynamically}
Now we look into more involved and practical example.
Suppose we have a program that reads a given input store and returns some outputs generated by prespecified plugins.
An input store is represented as a kind of extensible record indexed with a type-level list of fields, and plugins are also specified in type-level.
The following signature for the main logic illustrates the idea:
\begin{code}
type SPlugins ps = SList (ps :: [Plugin])
processStore :: All (RunsWith keys) ps
             => Store keys -> SPlugins ps -> Outputs ps

class IsPlugin (p :: Plugin) where
  data PluginOutput p
  type Runnable p (keys :: [StoreKey]) :: Constraint
  process :: Runnable p keys => proxy p -> Store keys -> PluginOutput p

class Runnable p keys => RunsWith keys p
instance Runnable p keys => RunsWith keys p
\end{code}
Thus, each plugin has a type-level constraint to determine if it is runnable with input stores with the given keys.
A function \hask{processStore} takes an input store and (a singleton of) a list of plugin runnable on the given store, and then returns the final outputs.
This works well if one explicitly specifies type variables \hask{keys} and \hask{ps} \emph{statically}.
Suppose that, however, now the situation is changed and we want to determine \hask{keys} and \hask{ps} \emph{dynamically}, depending on external configurations.

We assume the following API for extensible records:

\begin{code}
data Record (f :: k -> Type) (keys :: [k])
pattern EmptyRecord :: Record f '[]
pattern (:<) :: f k -> Record f keys -> Record f (k ': keys)
\end{code}

Here, \hask{Record f keys} is isomorphic to the record type with field labels in \hask{keys}, where each label \hask{k} is associated to the value of type \hask{f k}.
In practice, it is much more convenient to allow specify labels and corresponding field type independently, making \hask{f :: key -> val -> Type}.
Several efficient implementations can be found on Hackage~\cite{Kinoshita:2020aa,Sterling:2020aa,Thiemann:2020aa}.
Furthermore, it is desirable to use type-level ordered maps instead of lists to tune-up type-cheking speed.
Here, we adopt the above simple API for exposition.

Built on top of this API, we can now present the entire program architecture:
\begin{code}
data Plugin = PluginDouble | PluginGreet
  deriving (Read, Show, Eq, Ord, Typeable)
data StoreKey
  = IntStore
  | NameStore
  | PluginStore Plugin
  | GlobalStore
  deriving (Typeable, Eq, Ord, Show)

class IsPlugin (p :: Plugin) where
  data PluginOutput p
  type Runnable p (keys :: [StoreKey]) :: Constraint
  process :: Runnable p keys => proxy p -> Store keys -> PluginOutput p

newtype StoreEntry k = MkStoreEntry {storeEntry :: StoreVal k}
type Store = Record StoreEntry
type Outputs = Record PluginOutput

type family StoreVal (key :: StoreKey) :: Type where
  StoreVal 'IntStore = Int
  StoreVal 'NameStore = String
  StoreVal ('PluginStore p) = PluginStoreType p
  StoreVal 'GlobalStore = GlobalEnv

type SPlugins ps = SList (ps :: [Plugin])
processStore :: All (RunsWith keys) ps
             => Store keys -> SPlugins ps -> Outputs ps
processStore _ SNil = EmptyStore
processStore store (SCons p ps) = process p store :< processStore store ps
\end{code}

\subsection{Notes on Equality}
At this point, we have three type-level (homogeneous) equalities:
\begin{enumerate}
\item Built-in equality constraint \hask{a ~ b},
\item Boolean equality \hask{a == b}, which plays well with compound types, and
\item Boolean equality \hask{a === b}, which takes only the reflexivity into account.
\end{enumerate}
These three equalities can play their roles case-by-case, although their extension must coincide.
Hence, it is convenient to pack all these (non-)equalities into a single witness:

\begin{code}
data Equality a b where
  Equal :: ((a == b) ~ 'True, a ~ b, (a === b) ~ 'True) => Equality a b
  NonEqual
    :: ((a === b) ~ 'False, (a == b) ~ 'False) => Equality a b
\end{code}

As expressed by the constructor names, here \hask{Equal} witnesses the equality of given two types, and \hask{NonEqual} witnesses \emph{non}-equality.
In this way, \hask{Equality} packages both \emph{positive} (equal) and \emph{negative} (non-equal) witnesses.

One might wonder why we didn't mention equality \emph{constraint} \hask{a ~ b} in \hask{NonEqual}-case.
This is because GHC can infer that \hask{a :~: b} is not inhabited from the fact that \hask{(a === b) ~ 'False}:

\begin{code}
{-# LANGUAGE EmptyCase, LambdaCase #-}
import Data.Void
fromFalseEq :: (a === b) ~ 'False => a :~: b -> Void
fromFalseEq = \case {}
\end{code}


\end{document}
