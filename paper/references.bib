%% This BibTeX bibliography file was created using BibDesk.
%% https://bibdesk.sourceforge.io/

%% Created for 石井大海 at 2021-03-22 20:21:32 +0900 


%% Saved with string encoding Unicode (UTF-8) 



@online{demotion-repo,
	author = {Hiromi Ishii},
	date-added = {2021-03-22 20:20:01 +0900},
	date-modified = {2021-03-22 20:21:31 +0900},
	title = {\texttt{konn/demotion-paper}},
	url = {https://github.com/konn/demotion-paper},
	urldate = {2021-03-22},
	year = {2021}}

@inproceedings{Winant:2018wu,
	abstract = {Type classes are one of Haskell's most popular features and extend its type system with ad-hoc polymorphism. Since their conception, there were useful features that could not be offered because of the desire to offer two correctness properties: coherence and global uniqueness of instances. Coherence essentially guarantees that program semantics are independent from type-checker internals. Global uniqueness of instances is relied upon by libraries for enforcing, for example, that a single order relation is used for all manipulations of an ordered binary tree.  The features that could not be offered include explicit dictionary application and local instances, which would be highly useful in practice. In this paper, we propose a new design for offering explicit dictionary application, without compromising coherence and global uniqueness. We introduce a novel criterion based on GHC's type argument roles to decide when a dictionary application is safe with respect to global uniqueness of instances. We preserve coherence by detecting potential sources of incoherence, and prove it formally. Moreover, our solution makes it possible to use local dictionaries. In addition to developing our ideas formally, we have implemented a working prototype in GHC.},
	address = {New York, NY, USA},
	author = {Winant, Thomas and Devriese, Dominique},
	booktitle = {Proceedings of the 11th ACM SIGPLAN International Symposium on Haskell},
	date-added = {2021-02-22 23:42:14 +0900},
	date-modified = {2021-02-22 23:42:27 +0900},
	doi = {10.1145/3242744.3242752},
	isbn = {9781450358354},
	keywords = {dictionaries, coherence, Haskell, type classes},
	location = {St. Louis, MO, USA},
	numpages = {13},
	pages = {81--93},
	publisher = {Association for Computing Machinery},
	series = {Haskell 2018},
	title = {Coherent Explicit Dictionary Application for Haskell},
	url = {https://doi.org/10.1145/3242744.3242752},
	year = {2018},
	Bdsk-Url-1 = {https://doi.org/10.1145/3242744.3242752}}

@inproceedings{Noonan:2018aa,
	abstract = {Library authors often are faced with a design choice: should a function with preconditions be implemented as a partial function, or by returning a failure condition on incorrect use? Neither option is ideal. Partial functions lead to frustrating run-time errors. Failure conditions must be checked at the use-site, placing an unfair tax on the users who have ensured that the function's preconditions were correctly met.  In this paper, we introduce an API design concept called ``ghosts of departed proofs'' based on the following observation: sophisticated preconditions can be encoded in Haskell's type system with no run-time overhead, by using proofs that inhabit phantom type parameters attached to newtype wrappers. The user expresses correctness arguments by constructing proofs to inhabit these phantom types. Critically, this technique allows the library user to decide when and how to validate that the API's preconditions are met.  The ``ghosts of departed proofs'' approach to API design can achieve many of the benefits of dependent types and refinement types, yet only requires some minor and well-understood extensions to Haskell 2010. We demonstrate the utility of this approach through a series of case studies, showing how to enforce novel invariants for lists, maps, graphs, shared memory regions, and more.},
	address = {New York, NY, USA},
	author = {Noonan, Matt},
	booktitle = {Proceedings of the 11th ACM SIGPLAN International Symposium on Haskell},
	date-added = {2021-02-18 21:02:45 +0900},
	date-modified = {2021-02-18 21:02:54 +0900},
	doi = {10.1145/3242744.3242755},
	isbn = {9781450358354},
	keywords = {software engineering, formal methods, higher-rank types, API design},
	location = {St. Louis, MO, USA},
	numpages = {13},
	pages = {119--131},
	publisher = {Association for Computing Machinery},
	series = {Haskell 2018},
	title = {Ghosts of Departed Proofs (Functional Pearl)},
	url = {https://doi.org/10.1145/3242744.3242755},
	year = {2018},
	Bdsk-Url-1 = {https://doi.org/10.1145/3242744.3242755}}

@inbook{Kiselyov:2010aa,
	abstract = {Tony Hoare has always been a leader in writing down and proving properties of programs. To prove properties of programs automatically, the most widely used technology today is the ubiquitous type checker. Alas, static type systems inevitably exclude some good programs and allow some bad ones. Thus motivated, we describe some fun we have been having with Haskell, by making the type system more expressive without losing the benefits of automatic proof and compact expression. Specifically, we offer a programmer's tour of so-calledtype families, a recent extension to Haskell that allows functions on types to be expressed as straightforwardly as functions on values. This facility makes it easier for programmers to effectively extend the compiler by writing functional programs that execute during type checking. Source code for all the examples is available at http://research.microsoft.com/simonpj/papers/assoc-types/fun-with-type-funs.zip.},
	author = {Kiselyov, Oleg and Jones, Simon Peyton and Shan, Chung-chieh},
	booktitle = {Reflections on the Work of C.A.R. Hoare},
	date-added = {2021-02-18 20:19:43 +0900},
	date-modified = {2021-02-18 21:41:23 +0900},
	doi = {10.1007/978-1-84882-912-1_14},
	editor = {Roscoe, A.W. and Jones, Cliff B. and Wood, Kenneth R.},
	isbn = {978-1-84882-912-1},
	pages = {301--331},
	publisher = {Springer},
	title = {Fun with Type Functions},
	year = {2010},
	Bdsk-Url-1 = {https://doi.org/10.1007/978-1-84882-912-1_14}}

@article{Wadler:2015aa,
	abstract = {Connecting mathematical logic and computation, it ensures that some aspects of programming are absolute.},
	address = {New York, NY, USA},
	author = {Wadler, Philip},
	date-added = {2021-02-18 01:49:21 +0900},
	date-modified = {2021-02-18 01:49:24 +0900},
	doi = {10.1145/2699407},
	issn = {0001-0782},
	issue_date = {December 2015},
	journal = {Commun. ACM},
	month = nov,
	number = {12},
	numpages = {10},
	pages = {75--84},
	publisher = {Association for Computing Machinery},
	title = {Propositions as Types},
	url = {https://doi.org/10.1145/2699407},
	volume = {58},
	year = {2015},
	Bdsk-Url-1 = {https://doi.org/10.1145/2699407}}

@online{Kmett:2020ab,
	author = {Edward A. Kmett},
	date-added = {2021-02-17 21:05:35 +0900},
	date-modified = {2021-02-17 21:06:12 +0900},
	title = {\texttt{constraints}: Constraint manipulation},
	url = {https://hackage.haskell.org/package/constraints},
	urldate = {2021-02-17},
	year = {2020},
	Bdsk-Url-1 = {https://hackage.haskell.org/package/constraints}}

@article{Kiselyov:2004aa,
	author = {Kiselyov, Oleg and Shan, Chung-chieh},
	date-added = {2021-02-16 02:57:04 +0900},
	date-modified = {2021-02-16 02:57:04 +0900},
	doi = {10.1145/1017472.1017481},
	month = {01},
	pages = {33-44},
	title = {Functional pearl: Implicit configurations - Or, type classes reflect the values of types},
	year = {2004},
	Bdsk-Url-1 = {https://doi.org/10.1145/1017472.1017481}}

@online{Kmett:2020aa,
	author = {Edward A. Kmett},
	date-modified = {2021-02-16 02:55:27 +0900},
	title = {The \texttt{reflection} package},
	url = {https://hackage.haskell.org/package/reflection},
	urldate = {2020-02-16},
	year = {2020},
	Bdsk-Url-1 = {https://hackage.haskell.org/package/reflection}}

@online{GHC-Team:2020aa,
	author = {{GHC Team}},
	date-added = {2021-02-16 02:41:08 +0900},
	date-modified = {2021-02-18 00:54:02 +0900},
	title = {type checker Wiki Glasgow Haskell Compiler / GHC GitLab},
	url = {https://gitlab.haskell.org/ghc/ghc/wikis/plugins/type-checker},
	urldate = {2021-02-16},
	year = {2020},
	Bdsk-Url-1 = {https://gitlab.haskell.org/ghc/ghc/wikis/plugins/type-checker}}

@online{Thiemann:2020aa,
	author = {Alexander Thiemann},
	date-added = {2021-02-13 22:51:32 +0900},
	date-modified = {2021-02-13 22:51:46 +0900},
	title = {{superrecord}: Supercharged anonymous records},
	url = {https://hackage.haskell.org/package/superrecord},
	year = {2020},
	Bdsk-Url-1 = {https://hackage.haskell.org/package/superrecord}}

@online{Sterling:2020aa,
	author = {Jonathan Sterling},
	date-added = {2021-02-13 22:50:48 +0900},
	date-modified = {2021-02-13 22:51:08 +0900},
	title = {{vinyl}: Extensible Records},
	url = {https://hackage.haskell.org/package/vinyl},
	year = {2020},
	Bdsk-Url-1 = {https://hackage.haskell.org/package/vinyl}}

@online{Kinoshita:2020aa,
	author = {Fumiaki Kinoshita},
	date-added = {2021-02-13 22:49:23 +0900},
	date-modified = {2021-02-13 22:50:24 +0900},
	title = {{extensible}: Extensible, efficient, optics-friendly data types and effects},
	url = {https://hackage.haskell.org/package/extensible},
	year = {2020},
	Bdsk-Url-1 = {https://hackage.haskell.org/package/extensible}}

@online{GHC-Team:2021aa,
	author = {{GHC Team}},
	date-added = {2021-02-08 01:01:03 +0900},
	date-modified = {2021-02-08 01:02:28 +0900},
	title = {Data.Type.Equality},
	url = {https://hackage.haskell.org/package/base-4.14.1.0/docs/src/Data.Type.Equality.html#line-174},
	urldate = {2021-02-08},
	year = {2021},
	Bdsk-Url-1 = {https://hackage.haskell.org/package/base-4.14.1.0/docs/src/Data.Type.Equality.html#line-174}}

@inproceedings{10.1145/2503778.2503786,
	abstract = {Haskell's type system has outgrown its Hindley-Milner roots to the extent that it now stretches to the basics of dependently typed programming. In this paper, we collate and classify techniques for programming with dependent types in Haskell, and contribute some new ones. In particular, through extended examples---merge-sort and rectangular tilings---we show how to exploit Haskell's constraint solver as a theorem prover, delivering code which, as Agda programmers, we envy. We explore the compromises involved in simulating variations on the theme of the dependent function space in an attempt to help programmers put dependent types to work, and to inform the evolving language design both of Haskell and of dependently typed languages more broadly.},
	address = {New York, NY, USA},
	author = {Lindley, Sam and McBride, Conor},
	booktitle = {Proceedings of the 2013 ACM SIGPLAN Symposium on Haskell},
	date-added = {2021-02-07 19:33:37 +0900},
	date-modified = {2021-02-07 19:33:37 +0900},
	doi = {10.1145/2503778.2503786},
	isbn = {9781450323833},
	keywords = {invariants, proof search, data type promotion, singletons, dependent types},
	location = {Boston, Massachusetts, USA},
	numpages = {12},
	pages = {81--92},
	publisher = {ACM},
	series = {Haskell '13},
	title = {Hasochism: The Pleasure and Pain of Dependently Typed Haskell Programming},
	url = {https://doi.org/10.1145/2503778.2503786},
	year = {2013},
	Bdsk-Url-1 = {https://doi.org/10.1145/2503778.2503786}}

@inproceedings{Yorgey:2012,
	acmid = {2103795},
	address = {New York, NY, USA},
	author = {Yorgey, Brent A. and Weirich, Stephanie and Cretin, Julien and Peyton Jones, Simon and Vytiniotis, Dimitrios and Magalh\~{a}es, Jos{\'e} Pedro},
	booktitle = {Proceedings of the 8th ACM SIGPLAN Workshop on Types in Language Design and Implementation},
	date-added = {2021-02-07 19:32:06 +0900},
	date-modified = {2021-02-07 19:32:06 +0900},
	doi = {10.1145/2103786.2103795},
	isbn = {978-1-4503-1120-5},
	keywords = {haskell, kinds, polymorphism, promotion},
	location = {Philadelphia, Pennsylvania, USA},
	numpages = {14},
	pages = {53--66},
	publisher = {ACM},
	series = {TLDI '12},
	title = {Giving Haskell a Promotion},
	url = {http://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf},
	year = {2012},
	Bdsk-Url-1 = {http://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/2103786.2103795}}

@misc{singletons,
	author = {Richard Eisenberg},
	date-added = {2021-02-07 19:32:01 +0900},
	date-modified = {2021-02-07 19:32:01 +0900},
	keywords = {type-level programming, haskell, dependent types},
	title = {singletons},
	url = {http://hackage.haskell.org/package/singletons},
	year = {2012--2013},
	Bdsk-Url-1 = {http://hackage.haskell.org/package/singletons}}

@article{Eisenberg:2012,
	acmid = {2364522},
	address = {New York, NY, USA},
	author = {Eisenberg, Richard A. and Weirich, Stephanie},
	date-added = {2021-02-07 19:31:58 +0900},
	date-modified = {2021-02-07 19:31:58 +0900},
	doi = {10.1145/2430532.2364522},
	issn = {0362-1340},
	issue_date = {December 2012},
	journal = {SIGPLAN Not.},
	keywords = {dependently typed programming, gadts, haskell, singletons},
	month = sep,
	number = {12},
	numpages = {14},
	pages = {117--130},
	publisher = {ACM},
	title = {Dependently Typed Programming with Singletons},
	url = {http://www.cis.upenn.edu/~eir/papers/2012/singletons/paper.pdf},
	volume = {47},
	year = {2012},
	Bdsk-Url-1 = {http://www.cis.upenn.edu/~eir/papers/2012/singletons/paper.pdf},
	Bdsk-Url-2 = {http://dx.doi.org/10.1145/2430532.2364522}}


@inproceedings{Kiselyov:2004zz,
author = {Kiselyov, Oleg and L\"{a}mmel, Ralf and Schupke, Keean},
title = {Strongly Typed Heterogeneous Collections},
year = {2004},
isbn = {1581138504},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1017472.1017488},
doi = {10.1145/1017472.1017488},
abstract = {A heterogeneous collection is a datatype that is capable of storing data of different types, while providing operations for look-up, update, iteration, and others. There are various kinds of heterogeneous collections, differing in representation, invariants, and access operations. We describe HLIST - a Haskell library for strongly typed heterogeneous collections including extensible records. We illustrate HLIST's benefits in the context of type-safe database access in Haskell. The HLIST library relies on common extensions of Haskell 98. Our exploration raises interesting issues regarding Haskell's type system, in particular, avoidance of overlapping instances, and reification of type equality and type unification.},
booktitle = {Proceedings of the 2004 ACM SIGPLAN Workshop on Haskell},
pages = {96–107},
numpages = {12},
keywords = {type improvement, extensible records, type equality, type-indexed rows, collections, haskell, type-safe database access, dependently typed programming},
location = {Snowbird, Utah, USA},
series = {Haskell '04}
}