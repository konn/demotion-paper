%!TeX root = demotion-paper.tex
\documentclass[demotion-paper.tex]{subfiles}
\begin{document}
\section{Introduction}
Since Haskell had been given a Promotion~\cite{Yorgey:2012}, using Haskell with dependent types is a joy.
It's not only a joy: it gives us a neat language to express invariants of programs with type-level constraints.
But it also comes with pain: writing correct but maintainable code with dependently typed program in Haskell sometimes is a hard job, as explained by Lindley and McBride~\cite{10.1145/2503778.2503786}.
It is particularily hard when one tries to bridge a gap between types and expressions, to maintaining complex type constraints, and so on.

Here, we propose to borrow the wisdom from one of the great discovery in Computer Science and Logic: Curry--Howard correspondence.
It tells us that types are propositions and programs are proofs in intuitionistic logic, in a rigorous sense.
According to Brouwer--Heyting--Kolmogorov (BHK) interpretation\footnote{For the precise historical background, we refer readers to the article by Wadler~\cite{Wadler:2015aa}}, its informal ancestor, a proof of an intuitionistic proposition is some kind of a construction, or \emph{witness}, conveying the information of the proposition.
For example, proof of $\varphi \land \psi$ is given by the pair of proofs $T: \varphi$ and $S: \psi$; $\varphi \to \psi$ is given by a function taking a proof of $P$ and returns $Q$, ---and so on.
The interpretation of our particular interest in this paper is that of disjunction:
\begin{quote}
  A proof $T: P \vee Q$ is given by $\braket{i, S}$, where either $i = 0$ and $S: \varphi$ or $i = 1$ and $S: \psi$ holds.
\end{quote}
Although BHK interpretation is not as rigorous as Curry--Howard correspondence, its looseness allows us much broader interpretation.

This paper is organised as follows.
\begin{itemize}
  \item In \Cref{sec:gcd}, taking type-level GCD as an example, we demonstrate how to \emph{demote} closed typel-level functions involving type-level pattern-matching.
  In particular, we suggest to add \emph{witnessing} argument to such type-level functions to make compiler aware of evaluation paths.
  \item \Cref{sec:disj} demonstrates that we can emulate \emph{disjunctions} of type constraints, provided that constraints in question can be recovered from some statically computable \emph{witnesses}.
  We use a field retrieval of union of extensible records there.
  \item \Cref{sec:plugins} is devoted to a practical example of dependently-typed plugin system which can be dynamically type-checked at runtime.
  There, we see how the combination of Deferrable constraint pattern~\cite{Kmett:2020ab} and witness manipulation can be used to achieve this goal.
  We also discuss on a design of the witness of type-level equalities.
  \item Finally, we conclude in \Cref{sec:concl}.
\end{itemize}

\subsection{Preliminaries}
Throughout this paper, we use the standard method of \emph{singleton}~\cite{Eisenberg:2012} to simulate dependent types in Haskell.
In particular, we assume the following API\footnote{A working implementation is available at \texttt{https://github.com/XXXXX} (made available after blind reviews; for now, we provide the identical contents as the supplementary tarball.)}:

\begin{code}
type family Sing :: k -> Type

class Known a where
  sing :: Sing a
withKnown :: Sing a -> (Known a => r) -> r

data SomeSing k where
  MkSomeSing :: Sing (a :: k) -> SomeSing k
class HasSing k where
  type Demoted k 
  demote :: Sing (a :: k) -> Demoted k
  promote :: Demoted k -> SomeSing k

withPromoted :: HasSing k
  => Demoted k
  -> (forall x. Sing (x :: k) -> r) -> r

type FromJust :: ErrorMessage -> Maybe a -> a
type family FromJust err may where 
  FromJust err 'Nothing = TypeError err
  FromJust _ ('Just a)  = a

type instance Sing = (SNat :: Nat -> Type)
sNat :: KnownNat n => SNat n

withKnownNat :: SNat n -> (KnownNat n => r) -> r
(%+) :: SNat n -> SNat m -> SNat (n + m)
sMod :: SNat n -> SNat m -> SNat (n `Mod` m)
\end{code}

For the detail of singleton-based programming, we refer readers to Eisenberg--Weirich~\cite{Eisenberg:2012} and Lindley--McBride~\cite{10.1145/2503778.2503786}.

We use the following convention:
\begin{enumerate}
\item We prefix with the capital \hask{S} for singleton type: for example, \hask{SNat} is the singleton type of the kind \hask{Nat}.
\item For type-level function we use small \hask{s} as a prefix for singletonised  expression-level function: \hask{sMod} is the singletonised version of \hask{Mod}.
\item For operators, we prefix with \hask{%}: \hask{(%+)} is a singleton for type-level \hask{+}.
\end{enumerate}
\end{document}
